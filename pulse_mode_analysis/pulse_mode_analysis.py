"""
pulse_mode_analysis.py
docstring generated by chatgpt.

This module contains the PulseModeAnalysis class, which provides methods to analyze and process pulse mode measurement data. The class includes functionality for calculating the baseline, pulse shape parameters, and extracting the relevant pulse region from the input waveform data. Additionally, it calculates the charges for the pulse and pedestal regions.

The PulseModeAnalysis class can be used to process data from various sources, such as oscilloscopes or digitizers, where the input data is expected to be in the form of an array of waveform data.
"""
from dataclasses import dataclass
import logging
from typing import List, Tuple
from scipy.integrate import simps
import numpy as np

log = logging.getLogger(__name__)
INVALID_VALUE = -1


class PulseModeAnalysis:
    """
    A class for analysing pulse mode measurements.

    Attributes:
        sampling_interval (float): The time interval between samples in the waveform data.
        baseline_tmin (float): The starting time for the baseline time window.
        baseline_tmax (float): The finishing time for the baseline time window.
    """

    def __init__(
        self, sampling_interval: float, baseline_tmin: float, baseline_tmax: float
    ) -> None:
        self.sampling_interval = sampling_interval
        self.baseline_tmin = baseline_tmin
        self.baseline_tmax = baseline_tmax

    def get_simple_intensity(self, data, signal_mask=None):
        """
        Calculate a first aproximation of the PMT intensity and baseline of the waveform data.

        Args:
            data (np.ndarray): The waveform data.
            signal_mask (np.ndarray, optional): A boolean mask to select the signal region. If not given the whole waveform is integrated.
            baseline_mask (np.ndarray, optional): A boolean mask to select the baseline region. If not given, no baseline correction is made.

        Returns:
            Tuple[Tuple[float, float], Tuple[float, float]]: A tuple containing the mean and error of the charge and the baseline.
        """
        if signal_mask is None:
            signal_mask = np.ones(
                data[0].size
            )  # The entire waveform will be integrated

        baseline, baseline_error = self.get_baseline(data)

        charge = []
        for waveform in data:
            charge.append(
                simps(
                    waveform[signal_mask] - baseline,
                    self.time_axis[signal_mask],
                )
            )
        mean = np.mean(charge)
        error = np.std(charge) / np.sqrt(len(charge) - 1)
        return (mean, error), (baseline, baseline_error)

    def update_time_axis(self, waveform):
        """
        Update the time axis based on the length of the input waveform.

        Args:
            waveform (np.ndarray): The input waveform data.
        """
        log.debug("Updating/making time axis and baseline/signal masks...")
        self.time_axis = np.arange(0, waveform.size, 1) * self.sampling_interval

        self.baseline_mask = np.logical_and(
            self.time_axis > self.baseline_tmin,
            self.time_axis < self.baseline_tmax,
        )
        log.debug("Finished making time axis & masks!")

    def get_pulse_shape(
        self, x: np.ndarray, y: np.ndarray
    ) -> Tuple[float, float, float]:
        """
        Calculate the pulse shape parameters (Full Width at Half Maximum, Rise Time, and Fall Time).

        Args:
            x (np.ndarray): The x-axis data (time).
            y (np.ndarray): The y-axis data (voltage).

        Returns:
            Tuple[float, float, float]: A tuple containing the FWHM, RT, and FT.
        """

        log.debug("Calculating pulse shape parameters")
        if not isinstance(x, np.ndarray):
            raise TypeError("x must be a numpy array")
        if not isinstance(y, np.ndarray):
            raise TypeError("y must be a numpy array")

        max_index, max_val, x_at_max = self.get_maximum_index_and_coordinates(x, y)
        first_part = x <= x_at_max
        second_part = x >= x_at_max

        x1_ar, x2_ar = [], []
        limits = np.array([0.8, 0.5, 0.2])
        for limit in limits:
            for idx, val in enumerate(y[first_part][::-1]):
                if val < limit * max_val:
                    x1_ar.append(
                        np.interp(
                            limit * max_val,
                            [val, y[first_part][::-1][idx - 1]],
                            [x[first_part][::-1][idx], x[first_part][::-1][idx - 1]],
                        )
                    )
                    break
            for idx, val in enumerate(y[second_part]):
                if val < limit * max_val:
                    x2_ar.append(
                        np.interp(
                            limit * max_val,
                            [y[second_part][idx - 1], val],
                            [x[second_part][::-1][idx - 1], x[second_part][::-1][idx]],
                        )
                    )
                    break

        FWHM = x2_ar[1] - x1_ar[1]
        RT = x1_ar[0] - x1_ar[2]
        FT = x2_ar[2] - x2_ar[0]

        return FWHM, RT, FT

    def get_baseline(self, waveformBlock: np.ndarray) -> Tuple[float, float]:
        """
        Calculate the mean baseline level and its error for a given data block.

        Args:
            waveformBlock (np.ndarray): The input waveform data block.

        Returns:
            Tuple[float, float]: The mean baseline level and its error.
        """
        log.debug("Calculating mean baseline level of data block...")
        baselines = []
        for waveform in waveformBlock:
            baselines.append(waveform[self.baseline_mask])
        return np.average(baselines), np.std(baselines) / np.sqrt(len(baselines) - 1)

    def get_maximum_index_and_coordinates(self, x, y):
        """
        Get the index of the maximum value in the y-axis data, the amplitude and x value of maximum.

        Args:
            x (np.ndarray): The x-axis data (e.g., time).
            y (np.ndarray): The y-axis data (e.g., voltage).

        Returns:
            Tuple[int, float, float]: The index, value, and corresponding x value of the maximum point.
        """
        log.debug("Getting index max")
        max_index = np.argmax(y)
        y_at_max = y[max_index]
        x_at_max = x[max_index]
        return max_index, y_at_max, x_at_max

    def extract_pulse_region(self, waveform, max_index):
        """
        Extract the pulse region of interest from the input waveform.

        Args:
            waveform (np.ndarray): The input waveform data.
            max_index (int): The index of the maximum value in the waveform.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The pulse region and its corresponding time axis.
        """
        log.debug("Selecting region of interest")
        start_index = max_index - int(15e-9 / self.sampling_interval)
        end_index = max_index + int(15e-9 / self.sampling_interval)
        start_index = max(start_index, 0)
        end_index = min(end_index, len(waveform) - 1)
        pulse = waveform[start_index:end_index]
        pulse_time = self.time_axis[start_index:end_index]
        return pulse, pulse_time

    def integrate_waveform_in_Wb(self, time, amplitude):
        return simps(amplitude * 1e-3, time * 1e-9)

    def process_waveform(self, waveform) -> List:
        """
        Process the input waveform and extract the relevant parameters.

        Args:
            waveform (np.ndarray): The input waveform data.

        Returns:
            List: A list containing pedestal_charge, transit_time, charge, amplitude, FWHM, RT, and FT.
        """
        log.debug("Processing waveform")

        max_index, amplitude, transit_time = self.get_maximum_index_and_coordinates(
            self.time_axis, waveform
        )
        pulse, pulse_time = self.extract_pulse_region(waveform, max_index)

        try:
            FWHM, RT, FT = self.get_pulse_shape(pulse_time, pulse)
        except Exception as _:
            FWHM, RT, FT = [INVALID_VALUE] * 3
            log.debug(
                "Calculating pulse shape parameters failed, passing default values"
            )

        charge = self.integrate_waveform_in_Wb(pulse_time, pulse)
        pedestal_charge = self.integrate_waveform_in_Wb(
            self.time_axis[self.baseline_mask], waveform[self.baseline_mask]
        )

        log.debug("Finished processing waveform")
        return pedestal_charge, transit_time, charge, amplitude, FWHM, RT, FT
