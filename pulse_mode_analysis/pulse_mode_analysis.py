"""
pulse_mode_analysis.py
docstring generated by chatgpt.

This module contains the PulseModeAnalysis class, which provides methods to analyze and process pulse mode measurement data. The class includes functionality for calculating the baseline, pulse shape parameters, and extracting the relevant pulse region from the input waveform data. Additionally, it calculates the charges for the pulse and pedestal regions.

The PulseModeAnalysis class can be used to process data from various sources, such as oscilloscopes or digitizers, where the input data is expected to be in the form of an array of waveform data.
"""
from dataclasses import dataclass
import logging
from typing import List, Tuple
from scipy.integrate import simps
import numpy as np
from scipy import signal
import matplotlib.pyplot as plt
log = logging.getLogger(__name__)
INVALID_VALUE = -1


class PulseModeAnalysis:
    """
    A class for analysing pulse mode measurements.

    Attributes:
        sampling_interval (float): The time interval between samples in the waveform data.
        baseline_tmin (float): The starting time for the baseline time window.
        baseline_tmax (float): The finishing time for the baseline time window.
    """

    def __init__(
        self, sampling_interval: float, baseline_tmin: float, baseline_tmax: float
    ) -> None:
        self.sampling_interval = sampling_interval
        self.baseline_tmin = baseline_tmin
        self.baseline_tmax = baseline_tmax

    def get_simple_intensity(self, data, signal_mask=None):
        """
        Calculate a first aproximation of the PMT intensity and baseline of the waveform data.

        Args:
            data (np.ndarray): The waveform data.
            signal_mask (np.ndarray, optional): A boolean mask to select the signal region. If not given the whole waveform is integrated.

        Returns:
            Tuple[Tuple[float, float], Tuple[float, float]]: A tuple containing the mean and error of the charge and the baseline.
        """
        if not isinstance(data, np.ndarray):
            data = np.array(data)

        if signal_mask is None:
            signal_mask = np.ones(data[0].size).astype(
                "int"
            )  # The entire waveform will be integrated

        baseline, baseline_error = self.get_baseline(data)
        charge = []
        for waveform in data:
            charge.append(
                simps(
                    waveform[signal_mask] - baseline,
                    self.time_axis[signal_mask],
                )
            )
        mean = np.mean(charge)
        error = np.std(charge) / np.sqrt(len(charge) - 1)
        return (mean, error), (baseline, baseline_error)

    def update_time_axis(self, waveform):
        """
        Update the time axis based on the length of the input waveform.

        Args:
            waveform (np.ndarray): The input waveform data.
        """
        log.debug("Updating/making time axis and baseline/signal masks...")
        if not isinstance(waveform, np.ndarray):
            waveform = np.array(waveform)

        self.time_axis = np.arange(0, waveform.size, 1) * self.sampling_interval
        self.mid_index = int(waveform.size / 2)
        self.baseline_mask = np.logical_and(
            self.time_axis > self.baseline_tmin,
            self.time_axis < self.baseline_tmax,
        )
        log.debug("Finished making time axis & masks!")

    def get_pulse_shape(
        self,
        y: np.ndarray,
        x: np.ndarray = None,
    ) -> Tuple[float, float, float]:
        """
        Calculate the pulse shape parameters (Full Width at Half Maximum, Rise Time, and Fall Time).

        Args:
            x (np.ndarray): The x-axis data (time).
            y (np.ndarray): The y-axis data (voltage).

        Returns:
            Tuple[float, float, float]: A tuple containing the FWHM, RT, and FT.
        """

        log.debug("Calculating pulse shape parameters")
        if x is None:
            x = self.time_axis
        if not isinstance(x, np.ndarray):
            raise TypeError("x must be a numpy array")

        max_index = np.argmax(y)
        max_val = y[max_index]

        limits = np.array([0.8, 0.5, 0.2])
        x1_ar, x2_ar = [], []

        first_part = y[:max_index][::-1]
        second_part = y[max_index:]

        for limit in limits:
            for idx, val in enumerate(first_part):
                if val < limit * max_val:
                    x1_ar.append(
                        np.interp(
                            limit * max_val,
                            [val, first_part[idx - 1]],
                            [x[max_index - idx], x[max_index - idx + 1]],
                        )
                    )
                    break
            for idx, val in enumerate(second_part):
                if val < limit * max_val:
                    x2_ar.append(
                        np.interp(
                            limit * max_val,
                            [second_part[idx - 1], val],
                            [x[max_index + idx - 1], x[max_index + idx]],
                        )
                    )
                    break

        FWHM = abs(x2_ar[1] - x1_ar[1])
        RT = abs(x1_ar[2] - x1_ar[0])
        FT = abs(x2_ar[2] - x2_ar[0])

        return FWHM, RT, FT

    def get_baseline(self, waveformBlock: np.ndarray) -> Tuple[float, float]:
        """
        Calculate the mean baseline level and its error for a given data block.

        Args:
            waveformBlock (np.ndarray): The input waveform data block.

        Returns:
            Tuple[float, float]: The mean baseline level and its error.
        """
        log.debug("Calculating mean baseline level of data block...")
        baselines = []
        for waveform in waveformBlock:
            baselines.append(waveform[self.baseline_mask])
        return np.average(baselines), np.std(baselines) / np.sqrt(len(baselines) - 1)

    def get_maximum_index_and_coordinates(self, x, y):
        """
        Get the index of the maximum value in the y-axis data, the amplitude and x value of maximum.

        Args:
            x (np.ndarray): The x-axis data (e.g., time).
            y (np.ndarray): The y-axis data (e.g., voltage).

        Returns:
            Tuple[int, float, float]: The index, value, and corresponding x value of the maximum point.
        """
        log.debug("Getting index max")
        max_val = np.amax(y)
        max_indices = np.where(y == max_val)[0]
        max_index = max_indices[len(max_indices) // 2]
        y_at_max = y[max_index]
        x_at_max = x[max_index]
        return max_index, y_at_max, x_at_max

    def extract_pulse_region(self, waveform, max_index):
        """
        Extract the pulse region of interest from the input waveform.

        Args:
            waveform (np.ndarray): The input waveform data.
            max_index (int): The index of the maximum value in the waveform.

        Returns:
            Tuple[np.ndarray, np.ndarray]: The pulse region and its corresponding time axis.
        """
        log.debug("Selecting region of interest")
        start_index = max_index - int(15e-9 / self.sampling_interval)
        end_index = max_index + int(15e-9 / self.sampling_interval)
        start_index = max(start_index, 0)
        end_index = min(end_index, len(waveform) - 1)
        pulse = waveform[start_index:end_index]
        pulse_time = self.time_axis[start_index:end_index]
        return pulse, pulse_time

    def integrate_waveform_in_Wb(self, time, amplitude):
        return simps(amplitude * 1e-3, time)
        

    def process_SPW(self, waveform) -> List:
        """
        Process the input waveform and extract the relevant parameters.

        Args:
            waveform (np.ndarray): The input waveform data.

        Returns:
            List: A list containing pedestal_charge, transit_time, charge, amplitude, FWHM, RT, and FT.
        """
        log.debug("Processing waveform")

        max_index, amplitude, transit_time = self.get_maximum_index_and_coordinates(
            self.time_axis, waveform
        )
        pulse, pulse_time = self.extract_pulse_region(waveform, max_index)

        try:
            FWHM, RT, FT = self.get_pulse_shape(y=pulse, x=pulse_time)
        except Exception as _:
            FWHM, RT, FT = [INVALID_VALUE] * 3
            log.debug(
                "Calculating pulse shape parameters failed, passing default values"
            )

        charge = self.integrate_waveform_in_Wb(pulse_time, pulse)
        pedestal_charge = self.integrate_waveform_in_Wb(
            self.time_axis[self.baseline_mask], waveform[self.baseline_mask]
        )

        log.debug("Finished processing waveform")
        return pedestal_charge, transit_time, charge, amplitude, FWHM, RT, FT


    def process_MPW(self, waveform, trigger, calculate_pulse_shape = False) -> List:
        """
        Process the input waveform assuming no o many pulses and extract the relevant parameters.

        Args:
            waveform (np.ndarray): The input waveform data.
            trigger (np.ndarray): Amplitude level for pulse selection.
        Returns:
            List: A list containing pedestal_charge, transit_time, charge, amplitude, FWHM, RT, and FT.
        """
        log.debug("Processing waveform")

        indexMax, properties = signal.find_peaks(x=waveform, height=trigger, distance= int(20e-9/self.sampling_interval))
        log.debug(f"Number of peaks found: {len(indexMax)}")
        transit_time = []
        
        charge = []
        amplitude = []
        shape = []

        for index in indexMax:
            pulse, pulse_time = self.extract_pulse_region(waveform, index)

            if calculate_pulse_shape:
                try:
                    shape.append(self.get_pulse_shape(y=pulse, x=pulse_time))
                except Exception as _:
                    shape.append([INVALID_VALUE] * 3)
                    log.debug(
                        "Calculating pulse shape parameters failed, passing default values"
                    )
            charge.append(self.integrate_waveform_in_Wb(pulse_time, pulse))
            transit_time.append(self.time_axis[index])
            amplitude.append(waveform[index])
            
        pulse, pulse_time = self.extract_pulse_region(waveform, self.mid_index)
        pedestal_charge = self.integrate_waveform_in_Wb(pulse_time, pulse)
        
        log.debug("Finished processing waveform")
        return  pedestal_charge, np.average(waveform), transit_time, charge, amplitude, shape
